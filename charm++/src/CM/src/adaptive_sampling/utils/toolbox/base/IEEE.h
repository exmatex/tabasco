//
// File:	IEEE.h
// Package:	toolbox
// 
// 
// 
// Description:	IEEE routines to set up handlers and get signaling NaNs
//

#ifndef included_toolbox_IEEE
#define included_toolbox_IEEE

namespace toolbox {

/*!
 * @brief IEEE is a utility class for managing IEEE trap handlers and the
 * initialization of data to signaling NaNs, and for managing Posix constants
 * like INT_MAX, FLT_MAX, DBL_MAX, etc.  Signaling NaNs force
 * a trap if they are used in a numerical operation, so they are a
 * useful way to track uninitialized floating point data.  Signaling
 * NaN's may only be used for double and float data.  Setting
 * integer values to INT_MAX is a useful way to track uninitialized
 * integer values.
 *
 * The implementation of this class depends heavily on the particular
 * computer architecture and how it implements floating point arithmetic
 * and hardware traps.  Unfortunately, there is no POSIX/IEEE standard
 * on how to manage the traps generated by floating point calculations.
 */

struct IEEE
{
   /*!
    * Set up IEEE exception handlers so that normal IEEE exceptions will
    * cause a program abort.  This is useful for tracking down errors.
    * Note, however, that this may cause problems if your code relies on
    * IEEE underflow or overflow traps.
    */
   static void setupExceptionHandlers();

   /*!
    * Get the IEEE float signaling NaN on architectures that support it.
    * Using this value in a numerical expression will cause a program abort.
    */
   static float getSignalingFloatNaN();

   /*!
    * Get the IEEE double signaling NaN on architectures that support it.
    * Using this value in a numerical expression will cause a program abort.
    */
   static double getSignalingNaN();

   /*!
    * Get max int - INT_MAX (may be compiler dependent;
    * typical value is 2147483647).
    */
   static int getINT_MAX();

   /*!
    * Get min int - INT_MIN (may be compiler dependent;
    * typical value is -2147483648).
    */
   static int getINT_MIN();

   /*!
    * Get max float - FLT_MAX (may be compiler dependent; 
    * typical value is 3.40282e+38).
    */
   static float getFLT_MAX();

   /*!
    * Get min float - FLT_MIN (may be compiler dependent;
    * typical value is 1.17549e-38).
    */
   static float getFLT_MIN();

   /*!
    * Get epsilon for float - FLT_EPSILON (may be compiler dependent; 
    * typical value is 1.19209e-07).
    */
   static float getFLT_EPSILON();

   /*!
    * Get max double - DBL_MAX (may be compiler dependent; 
    * typical value is 1.79769e+308).
    */
   static double getDBL_MAX();

   /*!
    * Get min double - DBL_MIN (may be compiler dependent; 
    * typical value is 2.22507e-308).
    */
   static double getDBL_MIN();

   /*!
    * Get epsilon for double - DBL_EPSILON (may be compiler dependent; 
    * typical value is 2.22045e-16).
    */
   static double getDBL_EPSILON();

   /*!
    * Set supplied value to the signaling NaN.
    */
   static void setNaN(float &f);

   /*!
    * Set supplied value to the signaling NaN.
    */
   static void setNaN(double &d);

   /*!
    * Initialize an array of floats to signaling NaNs.  Before using this
    * array in any operation, the NaN value should be reset.  Otherwise,
    * an unrecoverable exception will result (as long as floating point 
    * exception handling is supported by the compiler).
    */
   static void initializeArrayToSignalingNaN(float *data, const int n = 1);

   /*!
    * Initialize an array of floats to signaling NaNs.  Before using this
    * array in any operation, the NaN value should be reset.  Otherwise,
    * an unrecoverable exception will result (as long as floating point 
    * exception handling is supported by the compiler).
    */
   static void initializeArrayToSignalingNaN(double *data, const int n = 1);

   /*!
    * Initialize an array of ints to system INT_MAX.  
    */
   static void initializeArrayToINT_MAX(int *data, const int n = 1);

   /*!
    * Initialize an array of ints to system INT_MIN.  
    */
   static void initializeArrayToINT_MIN(int *data, const int n = 1);

   /*!
    * Initialize an array of floats to system FLT_MAX.  
    */
   static void initializeArrayToFLT_MAX(float* data, const int n = 1);

   /*!
    * Initialize an array of floats to system FLT_MIN.  
    */
   static void initializeArrayToFLT_MIN(float* data, const int n = 1);

   /*!
    * Initialize an array of doubles to system DBL_MAX.  
    */
   static void initializeArrayToDBL_MAX(double* data, const int n = 1);

   /*!
    * Initialize an array of doubles to system DBL_MIN.  
    */
   static void initializeArrayToDBL_MIN(double* data, const int n = 1);

   /*!
    * Indicates whether the supplied value is NaN.
    */
   static bool isNaN(const float &f);

   /*!
    * Indicates whether the supplied value is NaN.
    */
   static bool isNaN(const double &d);

private:
   static float  s_signaling_nan_float;
   static double s_signaling_nan_double;
   static int    s_int_max;
   static int    s_int_min;
   static float  s_flt_max;
   static float  s_flt_min;
   static float  s_flt_epsilon;
   static double s_dbl_max;
   static double s_dbl_min;
   static double s_dbl_epsilon;


};


}

#ifndef DEBUG_NO_INLINE
#include "toolbox/base/IEEE.I"
#endif
#endif
